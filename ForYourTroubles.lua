-- This is a minified version of the whole project, btw eval.lua is basically a test for the eval function.
local a=(function()function modulo(b,c)local d=b;local e=0;while d>=c do e=e+1;d=d-c end;return e,d end;local f={{OP="^",FUNC=function(b,c)return b^c end},{OP="%",FUNC=function(b,c)return b%c end},{OP="/",FUNC=function(b,c)local e,g=modulo(b,c)local d=g*10;local h=12;local i=0;local j=e.."."if h==0 then return e end;while d~=0 do local k,l=modulo(d,c)d=l*10;j=j..k;i=i+1;if l==0 or i>=h then break end end;if j:sub(#j)=="."then j=j.."0"end;return tonumber(j)end},{OP="*",FUNC=function(b,c)return b*c end},{OP="-",FUNC=function(b,c)return b-c end},{OP="+",FUNC=function(b,c)return b+c end}}local m={floor=math.floor,sqrt=math.sqrt,sin=math.sin,log=math.log,abs=math.abs}local n={}n.Debug={AllowCoefficients=true,AllowHexdecimal=true,Enclosing={"(",")","[","]"},AllowLog=false,AllowSigns=true,AllowMFuncs=true,FixEulerConstant=true,LoopLimit=nil,Memoization=false,MemoFile="Memo"}local function o(p)local q={}for r,s in pairs(p)do q[r]=s end;return q end;local t=function(p,u)p[#p+1]=u end;local function v(p,w)local function x(y)local z={}for r,s in pairs(y)do t(z,{index=r,value=s,i=r,v=s})end;return z end;local A=x(p)local B=1;while true do local C=A[B]if C then w(C.i,C.v)else break end;B=B+1 end end;local D={}local E={}v(f,function(r,s)D[s.OP]=s end)v(m,function(r,s)E[r]=s end)n.OP=D;n.FUNC=E;n.Lexer=function(F,G,H,I)local F=F:gsub("–","-"):gsub("%s",""):gsub("%b||",function(z)return"abs("..z:sub(1,#z-1):sub(2)..")"end)local J={}local K,L,M=1,"",""local H=H or{n.Debug.Enclosing[1],n.Debug.Enclosing[2]}local I=I or{n.Debug.Enclosing[3],n.Debug.Enclosing[4]}if G and next(G)then for r in next,G do if r~="nan"and r~="inf"then assert(tonumber(r)==nil,"a variables name cannot be integer nor number value!")end end end;for r=1,#F do local z=F:sub(r,r)if not(rawget(n.OP,z)or(z==H[1]or z==H[2]or(z==I[1]or z==I[2])))then if K==1 then L=L..z;M=""end;if K==2 then M=M..z;L=""end elseif(rawget(n.OP,z)or(z==H[1]or z==H[2]or(z==I[1]or z==I[2]))or z=="-")and(F:sub(r-1,r-1)~="e"and n.Debug.FixEulerConstant)then if K==2 then if#M:gsub("%s","")~=0 then t(J,M)end;M=""K=1 else if#L:gsub("%s","")~=0 then t(J,L)end;K=2 end;t(J,z)L=""end;if r==#F then if K==2 then t(J,M)L=""end;if K==1 then t(J,L)M=""end end end;do for r,s in next,J do if G and G[s]then J[r]=G[s]elseif G then local N={}for O in next,G do if tostring(s):find(O)then t(N,O)end end;if N then local B=1;local P=s;for Q,O in next,N do P=P:gsub(O,"")local R=G[O]t(J,r+B,tonumber(R))B=B+1 end;J[r]=P;if tonumber(P)then J[r]=tonumber(P)end end end end end;n.FixTokens(J)return J end;local function S(T)if T=="+"or T=="-"then return 1 end;if T=="*"or T=="/"then return 2 end;if T=="^"or T=="%"then return 3 end;return end;n.Concatenate=function(J)local U=""for r,s in next,J do U=U..s end;return U end;n.GetBrackets=function(J,H,I)local V={}local W=0;local X={}local H=H or{n.Debug.Enclosing[1],n.Debug.Enclosing[2]}local I=I or{n.Debug.Enclosing[3],n.Debug.Enclosing[4]}for r,s in next,J do if H and s==H[1]then W=W+1;if W==1 then X={starti=r,tokens={}}else t(X.tokens,{index=r,value=s,i=r,v=s})end elseif H and s==H[2]then W=W-1;if W==0 then X.endi=r;t(V,X)X={}else t(X.tokens,{index=r,value=s,i=r,v=s})end elseif I and s==I[1]then W=W+1;if W==1 then X={starti=r,tokens={}}else t(X.tokens,{index=r,value=s,i=r,v=s})end elseif I and s==I[2]then W=W-1;if W==0 then X.endi=r;t(V,X)X={}else t(X.tokens,{index=r,value=s,i=r,v=s})end else if#tostring(s)>0 and X.tokens then t(X.tokens,{index=r,value=s,i=r,v=s})end end end;return V end;n.CalucateFirstOp=function(Y)local J=o(Y)local function Z(_)local a0,a1=nil,nil;v(_,function(r,s)if rawget(n.OP,s)and tonumber(s)==nil then if a1==nil and a0==nil then a0=S(s)a1={index=r,value=s,i=r,v=s}if n.Debug.AllowLog then print("First operation found:"..s)end;a0=S(s)a1={index=r,value=s,i=r,v=s}elseif a0<S(s)then a0=S(s)a1={index=r,value=s,i=r,v=s}if n.Debug.AllowLog then print("New operation found:"..s)end end end end)if a0 and a1 then local b=tonumber(_[a1.i-1])local c=tonumber(_[a1.i+1])if n.Debug.AllowLog and b and c then print(b..a1.value..c)end;return b,c,a1 end;return end;local b,c,a1=Z(J)if b and c and a1 then local a2=D[a1.v].FUNC;local a3=a2(b,c)J[a1.i]=a3;table.remove(J,a1.i-1)table.remove(J,a1.i)else assert(b~=nil,"x is nil, cannot do operation")assert(c~=nil,"y is nil, cannot do operation")assert(a1~=nil,"op is nil, cannot do operation")end;return J end;n.GetEvaluation=function(J)local a3=J;local a4=-1;if#J==0 then return error("No tokens cannot get estimate!",2)elseif#J==1 then return tonumber(a3[1])end;while#a3~=1 and a4<(n.Debug.LoopLimit or#J*2)do a4=a4+1;if n.Debug.AllowLog then print("Phase")end;a3=n.CalucateFirstOp(a3)end;return tonumber(a3[1])end;n.SetBrackets=function(Y)local J=o(Y)local V=n.GetBrackets(J)local a5={}local a6={}for r,s in next,V do a5[s.starti]=s end;local function a7(B)local a8=nil;for r,s in next,a5 do if s.starti<=B and s.endi>=B then a8=r;break end end;return a8 end;local function a9(Y)local a6={}for r,s in next,Y do if s.value then t(a6,s.value)else t(a6,s)end end;return a6 end;for r,s in next,J do if a5[r]then local aa=a9(a5[r].tokens)local ab=n.Evaluate(aa)t(a6,ab)elseif not a7(r)then t(a6,s)end end;n.FixTokens(a6)return a6 end;n.FixCoefficients=function(Y)local J=o(Y)local p={}for r,s in next,J do local ac=J[r+1]local ad=J[r-1]local ae=tonumber(s)~=nil and tonumber(ac)~=nil;local af=tonumber(s)~=nil and tonumber(ad)~=nil;t(p,s)if ae and n.Debug.AllowCoefficients then if n.Debug.AllowLog then print("Coefficient Found!")end;if r~=#J then t(p,"*")end elseif not n.Debug.AllowCoefficients and ae then error("There cannot be any coefficients!")elseif not n.Debug.AllowCoefficients and af then error("There cannot be any coefficients!")end end;n.FixTokens(p)return p end;n.FixSigns=function(Y)local J=o(Y)local p={}for r,s in next,J do local ac=J[r+1]local ad=J[r-1]local ag=J[r-2]local ae=ad=="-"and tonumber(s)~=nil and tonumber(ag)==nil;local af=s=="-"and tonumber(ac)~=nil;local ah=s=="-"and tonumber(ac)~=nil and tonumber(ad)~=nil;if ae and n.Debug.AllowSigns then if n.Debug.AllowLog then print("Negative integer Found!")end;t(p,-s)elseif not n.Debug.AllowSigns and ae and not ah then error("There cannot be any negative integers!")elseif not af and not ae then t(p,s)elseif ah then t(p,s)end end;n.FixTokens(p)return p end;n.GetFuncs=function(Y)local J=o(Y)local p={}local E=n.FUNC;for r,s in next,J do local ac=J[r+1]local ad=J[r-1]local ae=E[s]~=nil and tonumber(ac)~=nil;local af=E[ad]~=nil and tonumber(s)~=nil;if ae and n.Debug.AllowMFuncs then if n.Debug.AllowLog then print("Math function found!")end;t(p,E[s](ac))elseif not n.Debug.AllowMFuncs and ae then error("There cannot be any math functions!")elseif not af and not ae then t(p,s)end end;n.FixTokens(p)return p end;n.HexTokens=function(J)local a6={}if not n.Debug.AllowHexdecimal then return J end;for r,s in next,J do if tostring(s):sub(1,2)=="0x"then if tonumber(s,16)then a6[r]=tonumber(s,16)if n.Debug.AllowLog then print("Found Hexdecimal:"..s.."Converted: "..tonumber(s,16))end else a6[r]=s end else a6[r]=s end end;return n.FixTokens(a6)end;n.FixTokens=function(J)local a6={}for r,s in next,J do if#tostring(s):gsub("%s","")==0 then table.remove(J,r)else t(a6,s)end end;return a6 end;n.GetCheckSymbol=function(J)local a6={}local ai="[-]?%d+[.]?%d*"for r,s in next,J do if s=="√"then t(a6,"sqrt")elseif type(s)=="string"and s:sub(1,1):byte()==226 then local aj=tonumber(s:match(ai))if aj then t(a6,"sqrt")t(a6,aj)end else t(a6,s)end end;return n.FixTokens(a6)end;n.GetFinishedTokens=function(Y)local J=Y;local ak=n.SetBrackets(J)local al=n.HexTokens(ak)local am=n.GetCheckSymbol(al)local an=n.FixCoefficients(am)local ao=n.FixSigns(an)local w=n.GetFuncs(ao)return n.FixTokens(w)end;n.Evaluate=function(Y)if#Y==1 then return tonumber(Y[1])end;local J=n.GetFinishedTokens(Y)local a3=n.GetEvaluation(J)return a3 end;return n end)()local ap=(function(b,c)local aq={}for r=b,c do aq[#aq+1]=string.char(r)end;return aq end)(string.byte("a"),string.byte("z"))local function ar(as,i)local g,s=as%#ap,as/#ap-as%#ap/#ap;local i=""if s>0 and g~=0 then i=i..ar(s):upper()end;if s>0 and g==0 then if s~=1 then i=i..ar(s-1):upper()end end;if g>0 then i=i..ap[tonumber(tostring(g))]end;if g==0 then i=i..ap[#ap]end;return i end;local function at(au)local G={}local av=au:gsub("(%a+)%s*=%s*(%b())",function(s,z)z=z:sub(2,#z-1)return s.."="..at(z)end):gsub("%a+%s*=%s*[%-]?%d+[.]?%d*",function(z)local N=z:match("%a+")local as=z:match("[%-]?%d+[.]?%d*")G[N]=as;return""end):gsub("surface(%b())",function(s)local aw=s:sub(2,#s-1)..","aw=","..aw:gsub(",",function()return",,"end)local d,ax,ay;local Q=aw:gsub("%b,,",function(z)z=z:sub(2,#z-1)if d==nil then d=tonumber(z)elseif ax==nil then ax=tonumber(z)elseif ay==nil then ay=tonumber(z)end end)if d and ax and ay then return"(".."(("..d..")*("..ax..")*2) + (("..ay..")*("..d..")*2) + (("..ay..")*("..ax..")*2))"end end):gsub("area(%b())",function(s)local aw=s:sub(2,#s-1)..","aw=","..aw:gsub(",",function()return",,"end)local d,ax,ay;local Q=aw:gsub("%b,,",function(z)z=z:sub(2,#z-1)if d==nil then d=z elseif ax==nil then ax=z elseif ay==nil then ay=z end end)if d and ax and ay then return"(("..d..")*("..ax..")*("..ay.."))"elseif d and ax then return"(("..d..")*("..ax.."))"end end):gsub("percent(%b())",function(s)local aw=s:sub(2,#s-1)..","aw=","..aw:gsub(",",function()return",,"end)local az={}local Q=aw:gsub("%b,,",function(z)z=z:sub(2,#z-1)az[#az+1]=z end)local aA,as;for r,s in next,az do if s:find("%%")then aA=s:gsub("%%","")elseif as==nil then as=s end end;if aA and az[3]==nil then local b,c=as,aA;return"(("..b..") * (("..c..")/100))"elseif az[3]and aA then local b,c=as,aA;return"((1/("..c..") * ("..b..")/1) * 100)"else local b,c=az[1],az[2]return"((("..b..") * 100) / ("..c.."))"end end):gsub("fraction(%b())",function(s)local aw=s:sub(2,#s-1)..","aw=","..aw:gsub(",",function()return",,"end)local az={}local Q=aw:gsub("%b,,",function(z)z=z:sub(2,#z-1)az[#az+1]=z end)return"(("..az[1]..")/("..az[2].."))"end):gsub("fr(%b())",function(s)local aw=s:sub(2,#s-1)..","aw=","..aw:gsub(",",function()return",,"end)local az={}local Q=aw:gsub("%b,,",function(z)z=z:sub(2,#z-1)az[#az+1]=z end)return"(("..az[1]..")/("..az[2].."))"end):gsub("acr(%b())",function(s)local aw=s:sub(2,#s-1)..","aw=","..aw:gsub(",",function()return",,"end)local az={}local Q=aw:gsub("%b,,",function(z)z=z:sub(2,#z-1)az[#az+1]=z end)local aq,z,aB=az[1],az[2],az[3]return"( ("..aq..") * (("..z..") / ("..aB..")))"end):gsub("rate(%b())",function(s)local aw=s:sub(2,#s-1)..","aw=","..aw:gsub(",",function()return",,"end)local az={}local Q=aw:gsub("%b,,",function(z)z=z:sub(2,#z-1)az[#az+1]=z end)return"( ("..az[1]..") / ("..az[2].."))"end):gsub("(%d+)e(.?)(%d+)",function(aq,aC,z)local T=(function()if aC=="+"or aC=="-"then return aC else return"+"end end)()return"("..aq.." * ( 10 ^ ("..T:gsub("%+","")..z..")))"end):gsub("ption(%b())",function(s)local aw=s:sub(2,#s-1)..","aw=","..aw:gsub(",",function()return",,"end)local az={}local Q=aw:gsub("%b,,",function(z)z=z:sub(2,#z-1)az[#az+1]=z end)return"( ("..az[1]..") * ("..az[2]..") / ("..az[3].."))"end)local aD=a.Lexer(av,G)local aE,a3=pcall(a.Evaluate,aD)if aE then return tostring(a3)else if#av:gsub("%s","")>0 then return"Error"else return"No Input"end end end;local function aF(as)local aG=tostring(as-math.floor(as)):sub(2)if aG:len()>0 then if aG:find("9999")then return math.floor(as)+1 end end;return as end;local function aH(as,aI)if#as==0 or not tonumber(as)then return"No Input"end;local aJ=math.floor(as)local aK=as-aJ;local aL,aM,aN=0,1;local aO,aP,aQ=1,0;local b,aR,e,aS;repeat b=b and 1/(b-e)or aK;e,aS=math.floor(b),math.floor(b+0.5)aL,aM,aN=aM,e*aM+aL,aS*aM+aL;aO,aP,aQ=aP,e*aP+aO,aS*aP+aO;aR=aK-aN/aQ until math.abs(aR)<1e-15;if aQ==1 then return aN+aQ*aJ end;if aI then local aT,as=modulo(aN+aQ*aJ,aQ)return aT.."   "..as.." / "..aQ end;return aN+aQ*aJ.." / "..aQ end;local au=io.read("*l")or"0"local G={}local aU;if au:find("~")then local aV={}local aW=""for r=1,#au do local z=au:sub(r,r)if z=="~"then aV[#aV+1]=aW;aW=""elseif r==#au then aV[#aV+1]=aW..z else aW=aW..z end end;print("Answers")for r,s in next,aV do if s:sub(1,8)=="mixedfr:"then print("\t",ar(r).."\t:\t"..aH(at(s:sub(9)),true),"\t::EXP:\t",s:sub(4))elseif s:sub(1,3)=="fr:"then print("\t",ar(r).."\t:\t"..aH(at(s:sub(4))),"\t::EXP:\t",s:sub(4))else local ab=at(s)if aF(ab)~=ab then print("\t",ar(r).."\t:\t"..aF(at(s)),"\t::EXP:\t",s,"\t::ABS:\t",ab)else print("\t",ar(r).."\t:\t"..at(s),"\t::EXP:\t",s)end end end else if au:sub(1,8)=="mixedfr:"then print("Answer: "..aH(at(au:sub(9)),true))elseif au:sub(1,3)=="fr:"then print("Answer: "..aH(at(au:sub(4))))else local ab=at(au)print("Answer: "..aF(ab))if ab~=aF(ab)then print("\n\nAbsolute Answer: "..ab)end end end
-- Put this in any lua executor and make sure of stdbin
-- Sincerly, BBTLeg
