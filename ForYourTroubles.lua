-- This is a minified version of the whole project, btw eval.lua is basically a test for the eval function.
local a=(function()local function b(c,d)local e=c;local f=0;while e>=d do f=f+1;e=e-d end;return f,e end;local g={{OP="^",FUNC=function(c,d)return c^d end},{OP="%",FUNC=function(c,d)return c%d end},{OP="/",FUNC=function(c,d)local f,h=b(c,d)local e=h*10;local i=12;local j=0;local k=f.."."if i==0 then return f end;while e~=0 do local l,m=b(e,d)e=m*10;k=k..l;j=j+1;if m==0 or j>=i then break end end;if k:sub(#k)=="."then k=k.."0"end;return tonumber(k)end},{OP="*",FUNC=function(c,d)return c*d end},{OP="-",FUNC=function(c,d)return c-d end},{OP="+",FUNC=function(c,d)return c+d end}}local n={floor=math.floor,sqrt=math.sqrt,sin=math.sin,log=math.log,abs=math.abs}local o={}o.Debug={AllowCoefficients=true,AllowHexdecimal=true,Enclosing={"(",")","[","]"},AllowLog=false,AllowSigns=true,AllowMFuncs=true,FixEulerConstant=true,LoopLimit=nil,Memoization=false,MemoFile="Memo"}local p={}o.Memos=p;local function q(r)local s=io.open(r,"r")local t;t=s:read("*all")local u=io.open(r,"w+")u:write(t)u:close()local v;local w={t}local function x()v.contents=t;v.history=w end;local function y(z)u=io.open(r,"w+")u:write(z)u:close()w[#w+1]=z;t=z;x()end;local function A()t=s:read("*all")x()return t end;local type=r:match("%..*")if type then({function()end})[1]()type=type:sub(2)end;v={filename=r,name=r,filetype=type,type=type,contents=t,history=w,update=A,up=A,change=A,rewrite=y,open=function()return s,u end,correct=x}return v end;local v;if o.Debug.MemoFile and o.Debug.Memoization then v=q(o.Debug.MemoFile)o.FileLib=v end;local function B()if v then v.contents:gsub("%b[]",function(C)local D=C:match('%b""'):sub(2,-2)local E=C:sub(({C:find('%b""')})[2]+3,-3)p[D]=E end)end end;local function F()if not v then return end;local G=""for H,I in next,p do local J='["'..H..'"=('..tostring(I)..")]"G=G..J end;v.rewrite(G)return G end;local function K(H,I)if not o.Debug.Memoization then return end;p[H]=I;F()end;local function L(M)if not o.Debug.Memoization then return end;local N=o.Concatenate(M)return p[N],N end;B()local function O(P)local Q={}for H,I in pairs(P)do Q[H]=I end;return Q end;local R=function(P,E)P[#P+1]=E end;local function S(P,T)local function U(V)local C={}for H,I in pairs(V)do R(C,{index=H,value=I,i=H,v=I})end;return C end;local W=U(P)local X=1;while true do local Y=W[X]if Y then T(Y.i,Y.v)else break end;X=X+1 end end;local Z={}local _={}S(g,function(H,I)Z[I.OP]=I end)S(n,function(H,I)_[H]=I end)o.OP=Z;o.FUNC=_;o.Lexer=function(G,a0,a1,a2)local G=G:gsub("–","-"):gsub("%s",""):gsub("%b||",function(C)return"abs("..C:sub(1,#C-1):sub(2)..")"end)local M={}local a3,a4,a5=1,"",""local a1=a1 or{o.Debug.Enclosing[1],o.Debug.Enclosing[2]}local a2=a2 or{o.Debug.Enclosing[3],o.Debug.Enclosing[4]}if a0 and next(a0)then for H in next,a0 do if H~="nan"and H~="inf"then assert(tonumber(H)==nil,"a variables name cannot be integer nor number value!")end end end;for H=1,#G do local C=G:sub(H,H)if not(rawget(o.OP,C)or(C==a1[1]or C==a1[2]or(C==a2[1]or C==a2[2])))then if a3==1 then a4=a4 ..C;a5=""end;if a3==2 then a5=a5 ..C;a4=""end elseif(rawget(o.OP,C)or(C==a1[1]or C==a1[2]or(C==a2[1]or C==a2[2]))or C=="-")and(G:sub(H-1,H-1)~="e"and o.Debug.FixEulerConstant)then if a3==2 then if#a5:gsub("%s","")~=0 then R(M,a5)end;a5=""a3=1 else if#a4:gsub("%s","")~=0 then R(M,a4)end;a3=2 end;R(M,C)a4=""end;if H==#G then if a3==2 then R(M,a5)a4=""end;if a3==1 then R(M,a4)a5=""end end end;do for H,I in next,M do if a0 and a0[I]then M[H]=a0[I]elseif a0 then local a6={}for a7 in next,a0 do if tostring(I):find(a7)then R(a6,a7)end end;if a6 then local X=1;local a8=I;for a9,a7 in next,a6 do a8=a8:gsub(a7,"")local aa=a0[a7]R(M,H+X,tonumber(aa))X=X+1 end;M[H]=a8;if tonumber(a8)then M[H]=tonumber(a8)end end end end end;o.FixTokens(M)return M end;local function ab(ac)if ac=="+"or ac=="-"then return 1 end;if ac=="*"or ac=="/"then return 2 end;if ac=="^"or ac=="%"then return 3 end;return end;o.Concatenate=function(M)local N=""for H,I in next,M do N=N..I end;return N end;o.GetBrackets=function(M,a1,a2)local ad={}local ae=0;local af={}local a1=a1 or{o.Debug.Enclosing[1],o.Debug.Enclosing[2]}local a2=a2 or{o.Debug.Enclosing[3],o.Debug.Enclosing[4]}for H,I in next,M do if a1 and I==a1[1]then ae=ae+1;if ae==1 then af={starti=H,tokens={}}else R(af.tokens,{index=H,value=I,i=H,v=I})end elseif a1 and I==a1[2]then ae=ae-1;if ae==0 then af.endi=H;R(ad,af)af={}else R(af.tokens,{index=H,value=I,i=H,v=I})end elseif a2 and I==a2[1]then ae=ae+1;if ae==1 then af={starti=H,tokens={}}else R(af.tokens,{index=H,value=I,i=H,v=I})end elseif a2 and I==a2[2]then ae=ae-1;if ae==0 then af.endi=H;R(ad,af)af={}else R(af.tokens,{index=H,value=I,i=H,v=I})end else if#tostring(I)>0 and af.tokens then R(af.tokens,{index=H,value=I,i=H,v=I})end end end;return ad end;o.CalucateFirstOp=function(ag)local M=O(ag)local function ah(ai)local aj,ak=nil,nil;S(ai,function(H,I)if rawget(o.OP,I)and tonumber(I)==nil then if ak==nil and aj==nil then aj=ab(I)ak={index=H,value=I,i=H,v=I}if o.Debug.AllowLog then print("First operation found:"..I)end;aj=ab(I)ak={index=H,value=I,i=H,v=I}elseif aj<ab(I)then aj=ab(I)ak={index=H,value=I,i=H,v=I}if o.Debug.AllowLog then print("New operation found:"..I)end end end end)if aj and ak then local c=tonumber(ai[ak.i-1])local d=tonumber(ai[ak.i+1])if o.Debug.AllowLog and c and d then print(c..ak.value..d)end;return c,d,ak end;return end;local c,d,ak=ah(M)if c and d and ak then local al=Z[ak.v].FUNC;local am=al(c,d)M[ak.i]=am;table.remove(M,ak.i-1)table.remove(M,ak.i)else assert(c~=nil,"x is nil, cannot do operation")assert(d~=nil,"y is nil, cannot do operation")assert(ak~=nil,"op is nil, cannot do operation")end;return M end;o.GetEvaluation=function(M)local am=M;local an=-1;if#M==0 then return error("No tokens cannot get estimate!",2)elseif#M==1 then return tonumber(am[1])end;while#am~=1 and an<(o.Debug.LoopLimit or#M*2)do an=an+1;if o.Debug.AllowLog then print("Phase")end;am=o.CalucateFirstOp(am)end;return tonumber(am[1])end;o.SetBrackets=function(ag)local M=O(ag)local ad=o.GetBrackets(M)local ao={}local ap={}for H,I in next,ad do ao[I.starti]=I end;local function aq(X)local ar=nil;for H,I in next,ao do if I.starti<=X and I.endi>=X then ar=H;break end end;return ar end;local function as(ag)local ap={}for H,I in next,ag do if I.value then R(ap,I.value)else R(ap,I)end end;return ap end;for H,I in next,M do if ao[H]then local at=as(ao[H].tokens)local au=o.Evaluate(at)R(ap,au)elseif not aq(H)then R(ap,I)end end;o.FixTokens(ap)return ap end;o.FixCoefficients=function(ag)local M=O(ag)local P={}for H,I in next,M do local av=M[H+1]local aw=M[H-1]local ax=tonumber(I)~=nil and tonumber(av)~=nil;local ay=tonumber(I)~=nil and tonumber(aw)~=nil;R(P,I)if ax and o.Debug.AllowCoefficients then if o.Debug.AllowLog then print("Coefficient Found!")end;if H~=#M then R(P,"*")end elseif not o.Debug.AllowCoefficients and ax then error("There cannot be any coefficients!")elseif not o.Debug.AllowCoefficients and ay then error("There cannot be any coefficients!")end end;o.FixTokens(P)return P end;o.FixSigns=function(ag)local M=O(ag)local P={}for H,I in next,M do local av=M[H+1]local aw=M[H-1]local az=M[H-2]local ax=aw=="-"and tonumber(I)~=nil and tonumber(az)==nil;local ay=I=="-"and tonumber(av)~=nil;local aA=I=="-"and tonumber(av)~=nil and tonumber(aw)~=nil;if ax and o.Debug.AllowSigns then if o.Debug.AllowLog then print("Negative integer Found!")end;R(P,-I)elseif not o.Debug.AllowSigns and ax and not aA then error("There cannot be any negative integers!")elseif not ay and not ax then R(P,I)elseif aA then R(P,I)end end;o.FixTokens(P)return P end;o.GetFuncs=function(ag)local M=O(ag)local P={}local _=o.FUNC;for H,I in next,M do local av=M[H+1]local aw=M[H-1]local ax=_[I]~=nil and tonumber(av)~=nil;local ay=_[aw]~=nil and tonumber(I)~=nil;if ax and o.Debug.AllowMFuncs then if o.Debug.AllowLog then print("Math function found!")end;R(P,_[I](av))elseif not o.Debug.AllowMFuncs and ax then error("There cannot be any math functions!")elseif not ay and not ax then R(P,I)end end;o.FixTokens(P)return P end;o.HexTokens=function(M)local ap={}if not o.Debug.AllowHexdecimal then return M end;for H,I in next,M do if tostring(I):sub(1,2)=="0x"then if tonumber(I,16)then ap[H]=tonumber(I,16)if o.Debug.AllowLog then print("Found Hexdecimal:"..I.."Converted: "..tonumber(I,16))end else ap[H]=I end else ap[H]=I end end;return o.FixTokens(ap)end;o.FixTokens=function(M)local ap={}for H,I in next,M do if#tostring(I):gsub("%s","")==0 then table.remove(M,H)else R(ap,I)end end;return ap end;o.GetCheckSymbol=function(M)local ap={}local aB="[-]?%d+[.]?%d*"for H,I in next,M do if I=="√"then R(ap,"sqrt")elseif type(I)=="string"and I:sub(1,1):byte()==226 then local aC=tonumber(I:match(aB))if aC then R(ap,"sqrt")R(ap,aC)end else R(ap,I)end end;return o.FixTokens(ap)end;o.GetFinishedTokens=function(ag)local M=ag;local aD=o.SetBrackets(M)local aE=o.HexTokens(aD)local aF=o.GetCheckSymbol(aE)local aG=o.FixCoefficients(aF)local aH=o.FixSigns(aG)local T=o.GetFuncs(aH)return o.FixTokens(T)end;o.Evaluate=function(ag)if#ag==1 then return tonumber(ag[1])end;local aI,N=L(ag)if aI then if o.Debug.AllowLog then print("GOT MEMO ANSWER")end;K(N,aI)return aI end;local N=o.Concatenate(ag)local M=o.GetFinishedTokens(ag)local am=o.GetEvaluation(M)if o.Debug.AllowLog then print(am)end;K(N,am)return am end;return o end)()local aJ=(function(c,d)local aK={}for H=c,d do aK[#aK+1]=string.char(H)end;return aK end)(string.byte("a"),string.byte("z"))local function aL(aM,j)local h,I=aM%#aJ,aM/#aJ-aM%#aJ/#aJ;local j=""if I>0 and h~=0 then j=j..aL(I):upper()end;if I>0 and h==0 then if I~=1 then j=j..aL(I-1):upper()end end;if h>0 then j=j..aJ[tonumber(tostring(h))]end;if h==0 then j=j..aJ[#aJ]end;return j end;local function aN(aO)local a0={}local aP=aO:gsub("(%a+)%s*=%s*(%b())",function(I,C)C=C:sub(2,#C-1)return I.."="..aN(C)end):gsub("%a+%s*=%s*[%-]?%d+[.]?%d*",function(C)local a6=C:match("%a+")local aM=C:match("[%-]?%d+[.]?%d*")a0[a6]=aM;return""end):gsub("surface(%b())",function(I)local aQ=I:sub(2,#I-1)..","aQ=","..aQ:gsub(",",function()return",,"end)local e,aR,aS;local a9=aQ:gsub("%b,,",function(C)C=C:sub(2,#C-1)if e==nil then e=tonumber(C)elseif aR==nil then aR=tonumber(C)elseif aS==nil then aS=tonumber(C)end end)if e and aR and aS then return"(".."("..e.."*"..aR.."*2) + ("..aS.."*"..e.."*2) + ("..aS.."*"..aR.."*2)"..")"end end):gsub("area(%b())",function(I)local aQ=I:sub(2,#I-1)..","aQ=","..aQ:gsub(",",function()return",,"end)local e,aR,aS;local a9=aQ:gsub("%b,,",function(C)C=C:sub(2,#C-1)if e==nil then e=C elseif aR==nil then aR=C elseif aS==nil then aS=C end end)if e and aR and aS then return"("..e.."*"..aR.."*"..aS..")"elseif e and aR then return"("..e.."*"..aR..")"end end):gsub("percent(%b())",function(I)local aQ=I:sub(2,#I-1)..","aQ=","..aQ:gsub(",",function()return",,"end)local aT={}local a9=aQ:gsub("%b,,",function(C)C=C:sub(2,#C-1)aT[#aT+1]=C end)local aU,aM;for H,I in next,aT do if I:find("%%")then aU=I:gsub("%%","")elseif aM==nil then aM=I end end;if aU and aT[3]==nil then local c,d=aM,aU;return"("..c.." * ("..d.."/100))"elseif aT[3]and aU then local c,d=aM,aU;return'((1/'..d..' * '..c..'/1) * 100)'else local c,d=aT[1],aT[2]return"(("..c.." * 100) / "..d..")"end end):gsub("fraction(%b())",function(I)local aQ=I:sub(2,#I-1)..","aQ=","..aQ:gsub(",",function()return",,"end)local aT={}local a9=aQ:gsub("%b,,",function(C)C=C:sub(2,#C-1)aT[#aT+1]=C end)end)local aV=a.Lexer(aP,a0)local aW,am=pcall(a.Evaluate,aV)if aW then return tostring(am)else if#aP:gsub("%s","")>0 then return"Error"else return"No Input"end end end;print("advanced calculator easy and complicated\nInput: Type down below\n")local aO=io.read()print(aO)local a0={}if aO:find("~")then local aX={}local aY=""for H=1,#aO do local C=aO:sub(H,H)if C=="~"then aX[#aX+1]=aY;aY=""elseif H==#aO then aX[#aX+1]=aY..C else aY=aY..C end end;print("Answers")for H,I in next,aX do print("\t",aL(H).."\t:\t"..aN(I),"\t::EXP:\t",I)end else print("Answer: "..aN(aO))end
-- Put this in any lua executor and make sure of stdbin
